---
header-includes:
- \usepackage{xeCJK} 
- \usepackage{fontspec} 
- \setCJKmainfont{微軟正黑體} 
- \XeTeXlinebreaklocale "zh"
- \XeTeXlinebreakskip = 0pt plus 1pt
title: "Statistical Computing HW3"
author: "周聖諺"
date: "4/23/2021"
output: html_document
output:
  pdf_document: 
   latex_engine: xelatex
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Problem 1:

$$
X_1 = \sigma_{X_1} Z_1 + \mu_{X_1}
$$

$$
X_2 = \sigma_{X_2} (\rho Z_1 + \sqrt{1 - \rho^2} Z_2  + \mu_{X_2}
$$

The Expectation 

$$
E[X_1] = E[\sigma_{X_1} Z_1 + \mu_{X_1}] = \sigma_{X_1} E[Z_1] + \mu_{X_1} = \mu_{X_1}
$$
$$
E[X_2] = E[\sigma_{X_2} (\rho Z_1 + \sqrt{1 - \rho^2} Z_2  + \mu_{X_2}]
$$

$$
= \sigma_{X_2} E[\rho Z_1 + \sqrt{1 - \rho^2} Z_2]  + \mu_{X_2}
$$

$$
= \sigma_{X_2} (\rho E[Z_1] + \sqrt{1 - \rho^2} E[Z_2])  + \mu_{X_2} = \mu_{X_2}
$$

$$
X = \{ X_1, X_2 \}, \ E[X] = \{ \mu_{X_1}, \mu_{X_2} \}
$$

The Covariance

$$
\sigma_{X_1, X_2} = \sigma_{X_2, X_1} = E[(X_1 - \mu_{X_1})(X_2 - \mu_{X_2})]
$$

```{r }
#print(dgamma(1,scale=0.5,shape=2))

gen_binorm <- function(n, mu_1, mu_2, sigma_1, sigma_2, rho){
  z_1 <- rnorm(n, 0, 1)
  z_2 <- rnorm(n, 0, 1)
  z_bind <- rbind(z_1, z_2)
  
  x_1 <- sapply(z_1, function(z){return(sigma_1 * z + mu_1)})
  x_2 <- apply(z_bind, 2, function(z){return(sigma_2 * (rho * z[1] + sqrt(1 - rho * rho) * z[2]) + mu_2)})
  
  x_bind <- rbind(x_1, x_2)
  return(x_bind)
}

x <- gen_binorm(5000, 1, 2, 1, 2, 0.4)

print(cat("Mean of X_1: ", format(mean(x[1, ])), " \n"))
print(cat("Mean of X_2: ", format(mean(x[2, ])), " \n"))
print(cat("Covariance of (X_1, X_2): ", format(cov(x[1, ], x[2, ])), " \n"))
```

## Problem 2:

## Problem 3:

```{r}
gen_datas <- function(n){
  p_1 <- 0.6
  mu_1 <- 0
  sigma_1 <- 1
  mu_2 <- 3
  sigma_2 <- 1
  
  p <- runif(n, 0, 1)
  
  switch_func <- function(p){
    if(p < p_1){
      # Cluster 1
      return(rnorm(1, mu_1, sigma_1))
    }else{
      # Cluster 2
      return(rnorm(1, mu_2, sigma_2))
    }
  }
  x <- sapply(p, switch_func)
  
  return(x)
}

data <- gen_datas(5000)

hist(data, breaks=50, freq = FALSE)
```

```{r}
e_step <- function(ys, ws, mus, sigmas){
  k <- length(ws)
  n <- length(ys)
  likelihoods <- matrix(rep(0, k*n), nrow = n)
  weighted_likelihoods <- matrix(rep(0, k*n), nrow = n)
  
  # Evaluate the hidden variables
  for(j in 1:k){
    likelihoods[, j] <- sapply(ys, dnorm, mus[j], sigmas[j])
    weighted_likelihoods[, j] <- ws[j] * likelihoods[, j]
  }
  # gamma_i
  weighted_likelihoods <- weighted_likelihoods / rowSums(weighted_likelihoods)
  
  return(weighted_likelihoods)
}

m_step <- function(ys, ws, mus, sigmas, gammas){
  k <- length(ws)
  n <- length(ys)
  
  #Maximize the estimate
  for(j in 1:k){
    sum_gammas <- sum(gammas[, j])
    mus[j] <- sum(ys * gammas[, j]) / sum_gammas
    sigmas[j] <- sqrt(sum(gammas[, j] * (ys - mus[j])^2) / sum_gammas)
    ws[j] <- mean(gammas[, j])
  }
  
  return(rbind(ws, mus, sigmas))
}

em <- function(ys, k, threshold=1e-9, max_iter=201){
  mus <- runif(k)
  sigmas <- runif(k)
  ws <- rep(1/k, k)

  for(i in 1:max_iter){
    # Record old values
    old_params <- params
    
    gammas <- e_step(data, ws, mus, sigmas)
    params <- m_step(data, ws, mus, sigmas, gammas)
    #print(gammas)
    
    # Update parameters
    ws <- params[1, ]
    mus <- params[2, ]
    sigmas <- params[3, ]
    
    # Until converge
    if(abs(mean(params - old_params)) < threshold){
      break
    }
    
    #if(i %% 10 == 1){
    #  print(cat("Iter ", i))
    #  print(params)
    #}
  }
  return(params)
}

em(data, 2)
```

